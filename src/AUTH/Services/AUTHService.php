<?php
namespace AUTH\Services;

use AUTH\Exception\EmailResetFailedException;
use AUTH\Exception\EmailWrongPasswordException;
use AUTH\Models\LoginAccount;
use AUTH\Models\LoginAccountQuery;
use AUTH\Models\LoginSessionQuery;
use PSFS\base\Logger;
use PSFS\base\Security;
use PSFS\base\Service;

/**
* Class AUTHService
* @package AUTH\Services
* @author Fran López <fran.lopez84@hotmail.es>
* @version 1.0
* Autogenerated service [2017-03-02 10:36:03]
*/
class AUTHService extends Service {

    const EMAIL_ERROR_RESET_TOKEN_NOT_FOUND = 460;
    const EMAIL_ERROR_RESET_PASS_NOT_FOUND = 461;
    const EMAIL_ERROR_RESET_PASS_NOT_VALID = 462;
    const EMAIL_ERROR_RESET_INVALID_TOKEN = 463;
    const EMAIL_ERROR_RESET_FORBIDDEN = 464;
    const EMAIL_ERROR_RESET_GENERAL_ERROR = 465;

    /**
     * @param LoginAccount $account
     * @return bool
     */
    public function resetAccount(LoginAccount $account) {
        $account->setResetToken(sha1(uniqid(time())));
        $now = new \DateTime();
        $now->modify('+1 week');
        $account->setRefreshRequest($now);
        return false !== $account->save();
    }

    /**
     * @param LoginAccount $account
     * @param $sessionToken
     * @return bool
     */
    public function logoutSession(LoginAccount $account, $sessionToken) {
        $logout = false;
        $session = LoginSessionQuery::create()
            ->filterByIdAccount($account->getPrimaryKey())
            ->filterByToken($sessionToken)
            ->findOne();
        if(null !== $session) {
            $previousActive = $session->getActive();
            $session->setActive(false);
            $logout = false !== $session->save();
            if($logout && $previousActive) {
                Security::getInstance()->updateUser(null);
                Security::getInstance()->updateSession();
            }
        }
        return $logout;
    }

    public static function get_ip_address() {
        // check for shared internet/ISP IP
        if (!empty($_SERVER['HTTP_CLIENT_IP']) && self::validate_ip($_SERVER['HTTP_CLIENT_IP'])) {
            return $_SERVER['HTTP_CLIENT_IP'];
        }

        // check for IPs passing through proxies
        if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {
            // check if multiple ips exist in var
            if (strpos($_SERVER['HTTP_X_FORWARDED_FOR'], ',') !== false) {
                $iplist = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);
                foreach ($iplist as $ip) {
                    if (self::validate_ip($ip))
                        return $ip;
                }
            } else {
                if (self::validate_ip($_SERVER['HTTP_X_FORWARDED_FOR']))
                    return $_SERVER['HTTP_X_FORWARDED_FOR'];
            }
        }
        if (!empty($_SERVER['HTTP_X_FORWARDED']) && self::validate_ip($_SERVER['HTTP_X_FORWARDED']))
            return $_SERVER['HTTP_X_FORWARDED'];
        if (!empty($_SERVER['HTTP_X_CLUSTER_CLIENT_IP']) && self::validate_ip($_SERVER['HTTP_X_CLUSTER_CLIENT_IP']))
            return $_SERVER['HTTP_X_CLUSTER_CLIENT_IP'];
        if (!empty($_SERVER['HTTP_FORWARDED_FOR']) && self::validate_ip($_SERVER['HTTP_FORWARDED_FOR']))
            return $_SERVER['HTTP_FORWARDED_FOR'];
        if (!empty($_SERVER['HTTP_FORWARDED']) && self::validate_ip($_SERVER['HTTP_FORWARDED']))
            return $_SERVER['HTTP_FORWARDED'];

        // return unreliable ip since all else failed
        return $_SERVER['REMOTE_ADDR'];
    }

    /**
     * Ensures an ip address is both a valid IP and does not fall within
     * a private network range.
     */
    public static function validate_ip($ip) {
        if (strtolower($ip) === 'unknown')
            return false;

        // generate ipv4 network address
        $ip = ip2long($ip);

        // if the ip is set and not equivalent to 255.255.255.255
        if ($ip !== false && $ip !== -1) {
            // make sure to get unsigned long representation of ip
            // due to discrepancies between 32 and 64 bit OSes and
            // signed numbers (ints default to signed in PHP)
            $ip = sprintf('%u', $ip);
            // do private network range checking
            if ($ip >= 0 && $ip <= 50331647) return false;
            if ($ip >= 167772160 && $ip <= 184549375) return false;
            if ($ip >= 2130706432 && $ip <= 2147483647) return false;
            if ($ip >= 2851995648 && $ip <= 2852061183) return false;
            if ($ip >= 2886729728 && $ip <= 2887778303) return false;
            if ($ip >= 3221225984 && $ip <= 3221226239) return false;
            if ($ip >= 3232235520 && $ip <= 3232301055) return false;
            if ($ip >= 4294967040) return false;
        }
        return true;
    }

    /**
     * @param array $data
     * @return bool
     * @throws EmailResetFailedException
     * @throws \Exception
     */
    public function resetPassword(array $data) {
        if(array_key_exists('token', $data)) {
            if(array_key_exists('password', $data)) {
                try {
                    EmailService::checkPassword($data['password']);
                    $account = LoginAccountQuery::getAccountForReset($data['token']);
                    if(null !== $account) {
                        $now = new \DateTime();
                        if(null !== $account->getRefreshRequest() && $now < $account->getRefreshRequest()) {
                            $password = EmailService::encryptPassword($data['password']);
                            $account->setAccessToken($password)
                                ->setRefreshToken($password)
                                ->setRefreshRequest(null)
                                ->setResetToken(null);
                            $reseted = false !== $account->save();
                        } else {
                            throw new EmailResetFailedException(_('Ha expirado el plazo para resetear la contraseña'), self::EMAIL_ERROR_RESET_FORBIDDEN);
                        }
                    } else {
                        throw new EmailResetFailedException(_('No se ha encontrado el usuario para resetear la contraseña'), self::EMAIL_ERROR_RESET_INVALID_TOKEN);
                    }
                } catch(\Exception $e) {
                    Logger::log($e->getMessage(), LOG_ERR, $data);
                    if($e instanceof EmailWrongPasswordException) {
                        throw new EmailResetFailedException($e->getMessage(), self::EMAIL_ERROR_RESET_PASS_NOT_VALID);
                    } else {
                        throw $e;
                    }
                }
            } else {
                throw new EmailResetFailedException(_('Es necesario una nueva password'), self::EMAIL_ERROR_RESET_PASS_NOT_FOUND);
            }
        } else {
            throw new EmailResetFailedException(_('Es necesario el token del usuario'), self::EMAIL_ERROR_RESET_TOKEN_NOT_FOUND);
        }
        return $reseted;
    }
}
