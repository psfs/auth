<?php
namespace AUTH\Services\base;

use AUTH\Dto\AuthUserDto;
use AUTH\Exception\AuthApiAccessRestrictedException;
use AUTH\Exception\AuthProviderNotConfiguredException;
use AUTH\Exception\InvalidCallbackParametersException;
use AUTH\Models\LoginAccount;
use AUTH\Models\LoginProviderQuery;
use AUTH\Models\LoginSessionQuery;
use Propel\Runtime\Exception\PropelException;
use PSFS\base\config\Config;
use PSFS\base\Logger;
use PSFS\base\Router;
use PSFS\base\Security;
use PSFS\base\Service;

/**
* Class AUTHService
* @package AUTH\Services
* @author Fran López <fran.lopez84@hotmail.es>
* @version 1.0
* Autogenerated service [2017-02-20 00:27:02]
*/
abstract class AUTHService extends Service {
    const FLOW_LOGIN = 1;
    const FLOW_REGISTER = 2;

    public static $client;
    /**
     * @var \AUTH\Models\LoginProvider
     */
    protected $provider;
    /**
     * @var boolean
     */
    protected $debug;
    /**
     * @var array
     */
    protected $scopes = [];
    /**
     * @var string
     */
    public $base;

    /**
     * @return string
     */
    abstract public function getProviderName();

    /**
     * @param string $callbackUri
     * @param integer $flow
     * @return mixed
     */
    abstract public function getClient($callbackUri, $flow = self::FLOW_LOGIN);

    /**
     * @param integer $flow
     * @return string
     */
    abstract public function getAuthUrl($flow = self::FLOW_LOGIN);

    /**
     * @param array $query
     * @param  integer $flow
     * @return AuthUserDto|null
     * @throws InvalidCallbackParametersException
     */
    abstract public function authenticate(array $query, $flow = self::FLOW_LOGIN);

    /**
     * @param array $auth
     * @param integer $flow
     * @return AuthUserDto|null
     */
    abstract public function getUser(array $auth, $flow = self::FLOW_LOGIN);

    /**
     * @param array $scopes
     */
    public function setScopes(array $scopes) {
        $this->scopes = $scopes;
    }

    /**
     * @throws AuthProviderNotConfiguredException
     */
    public function init()
    {
        parent::init();
        $this->debug = Config::getParam('debug', false);
        $this->provider = LoginProviderQuery::getProvider($this->getProviderName(), $this->debug, Config::getParam('psfs.auth.customer_code'));
        if(null === $this->provider) {
            Logger::log($this->getProviderName() . ' not defined for ' . ($this->debug) ? ' debug mode' : ' production mode');
            $this->provider = LoginProviderQuery::getProvider($this->getProviderName(), !$this->debug, Config::getParam('psfs.auth.customer_code'));
            if(null === $this->provider) {
                throw new AuthProviderNotConfiguredException(t('No se ha configurado ningún proveedor de redes sociales todavía'), 503);
            }
        }
        $this->base = preg_replace('/\/$/', '', Config::getParam('login.base', Router::getInstance()->getRoute('', true)));
    }

    /**
     * @throws AuthApiAccessRestrictedException
     */
    public static function checkAccess() {
        $isAdmin = Security::getInstance()->canAccessRestrictedAdmin();
        if(!$isAdmin) {
            throw new AuthApiAccessRestrictedException(t('Only administrators can access auth models'), 403);
        }
    }

    /**
     * @param LoginAccount $account
     * @return bool
     * @throws PropelException
     */
    public function resetAccount(LoginAccount $account) {
        $account->setResetToken(sha1(uniqid(time())));
        $now = new \DateTime();
        $now->modify('+1 week');
        $account->setRefreshRequest($now);
        return false !== $account->save();
    }

    /**
     * @param LoginAccount $account
     * @param $sessionToken
     * @return bool
     * @throws PropelException
     */
    public function logoutSession(LoginAccount $account, $sessionToken) {
        $logout = false;
        $session = LoginSessionQuery::create()
            ->filterByIdAccount($account->getPrimaryKey())
            ->filterByToken($sessionToken)
            ->findOne();
        if(null !== $session) {
            $previousActive = $session->getActive();
            $session->setActive(false);
            $logout = false !== $session->save();
            if($logout && $previousActive) {
                Security::getInstance()->updateUser(null);
                Security::getInstance()->updateSession();
            }
        }
        return $logout;
    }

    public static function getIpAddress() {
        // check for shared internet/ISP IP
        if (!empty($_SERVER['HTTP_CLIENT_IP']) && self::validateIp($_SERVER['HTTP_CLIENT_IP'])) {
            return $_SERVER['HTTP_CLIENT_IP'];
        }

        // check for IPs passing through proxies
        if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {
            // check if multiple ips exist in var
            if (strpos($_SERVER['HTTP_X_FORWARDED_FOR'], ',') !== false) {
                $iplist = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);
                foreach ($iplist as $ip) {
                    if (self::validateIp($ip))
                        return $ip;
                }
            } else {
                if (self::validateIp($_SERVER['HTTP_X_FORWARDED_FOR']))
                    return $_SERVER['HTTP_X_FORWARDED_FOR'];
            }
        }
        if (!empty($_SERVER['HTTP_X_FORWARDED']) && self::validateIp($_SERVER['HTTP_X_FORWARDED']))
            return $_SERVER['HTTP_X_FORWARDED'];
        if (!empty($_SERVER['HTTP_X_CLUSTER_CLIENT_IP']) && self::validateIp($_SERVER['HTTP_X_CLUSTER_CLIENT_IP']))
            return $_SERVER['HTTP_X_CLUSTER_CLIENT_IP'];
        if (!empty($_SERVER['HTTP_FORWARDED_FOR']) && self::validateIp($_SERVER['HTTP_FORWARDED_FOR']))
            return $_SERVER['HTTP_FORWARDED_FOR'];
        if (!empty($_SERVER['HTTP_FORWARDED']) && self::validateIp($_SERVER['HTTP_FORWARDED']))
            return $_SERVER['HTTP_FORWARDED'];

        // return unreliable ip since all else failed
        return $_SERVER['REMOTE_ADDR'];
    }

    /**
     * Ensures an ip address is both a valid IP and does not fall within
     * a private network range.
     */
    public static function validateIp($ip) {
        if (strtolower($ip) === 'unknown')
            return false;

        // generate ipv4 network address
        $ip = ip2long($ip);

        // if the ip is set and not equivalent to 255.255.255.255
        if ($ip !== false && $ip !== -1) {
            // make sure to get unsigned long representation of ip
            // due to discrepancies between 32 and 64 bit OSes and
            // signed numbers (ints default to signed in PHP)
            $ip = sprintf('%u', $ip);
            // do private network range checking
            if ($ip >= 0 && $ip <= 50331647) return false;
            if ($ip >= 167772160 && $ip <= 184549375) return false;
            if ($ip >= 2130706432 && $ip <= 2147483647) return false;
            if ($ip >= 2851995648 && $ip <= 2852061183) return false;
            if ($ip >= 2886729728 && $ip <= 2887778303) return false;
            if ($ip >= 3221225984 && $ip <= 3221226239) return false;
            if ($ip >= 3232235520 && $ip <= 3232301055) return false;
            if ($ip >= 4294967040) return false;
        }
        return true;
    }

    /**
     * @return array
     */
    public function getScopes() {
        if(!count($this->scopes)) {
            $providerScopes = $this->provider->getScopes();
            if(strlen($providerScopes)) {
                $this->scopes = explode(",", $providerScopes);
            } else {
                $this->scopes = $this->getProviderDefaultScopes();
            }
        }
        return $this->scopes;
    }

    /**
     * @return array
     */
    protected function getProviderDefaultScopes() {
        return [];
    }
}
